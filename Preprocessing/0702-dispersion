{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Ch9-3. 산포 통계량\n",
    "\n",
    "산포란 데이터가 얼마나 퍼져있는지를 의미한다.  \n",
    "같은 확률 밀도 함수라고 했을 경우, 산포가 작은 변수는 한 값에 몰려있고, 산포가 큰 변수는 넓게 퍼져있다. 산포 통계량이란 데이터의 산포를 나타내는 통계량이다.  \n",
    "\n",
    "## 분산과 표준 편차\n",
    "- 편차 : 한 샘플이 평균으로부터 떨어진 거리 $(x_i - \\mu)$  \n",
    "- 분산 : 편차의 제곱의 평균  \n",
    "$$ \\frac {\\Sigma^{n}_{(i=1)} (x_i - \\mu)^2} {n-1} $$\n",
    "이산 확률 변수에서 $$ {\\displaystyle \\operatorname {Var} (X)=\\sum _{i=1}^{n}p_{i}\\cdot (x_{i}-\\mu )^{2}} $$\n",
    "완전 연속 확률 변수에서 $${\\displaystyle \\operatorname {Var} (X)=\\int _{-\\infty }^{+\\infty }x^{2}f(x)\\,dx-\\mu ^{2}}$$  \n",
    "    - *참고 : https://ko.wikipedia.org/wiki/%EB%B6%84%EC%82%B0*\n",
    "    - 편차의 합은 항상 0이 되기 때문에, 0이 되는 것을 방지하기 위해 제곱을 사용.  \n",
    "    - 자유도가 0(모분산)이면 n-1로 나누지 않고 n으로 나눔.  \n",
    "        - 불편통계량이라는 부분이라 어려워서 skip\n",
    "- 표준편차 : 분산의 제곱근\n",
    "    - 분산에서 제곱의 영향을 없앤 지표\n",
    "    - 특별한 경우를 제외하고는 분산보다 많이 씀.\n",
    "    \n",
    "## 변동계수(coefficient of variation, CV)\n",
    "분산과 표준편차 모두 값의 스케일에 크게 영향을 받아서, 상대적인 산포를 보여주는데 부적합하다. \n",
    "- 따라서 피처간의 비교, 상대적인 것을 보기 위해서는 변수를 스케일링한 뒤, 분산 혹은 표준편차를 구해야 한다.  \n",
    "- 만약 모든 데이터가 양수인 경우에는 변돈계수(상대 표준편차)를 사용할 수 있다.  \n",
    "    - 변동계수 : $ 표준편차 / 산술 평균 $  \n",
    "        - 평균이 0인 경우 사용할 수 없음  \n",
    "        - 만약 음수가 있다면 평균이 음수에 의해 작아지기 때문에 실제 산포와 거리가 멀어질 수 있어서, 모든 데이터가 양수인 경우가 아니면 잘 쓰이지 않는다. \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 파이썬을 이용한 분산, 표준편차, 변동계수 계산\n",
    "\n",
    "`ddof` 는 자유도를 의미한다. 아주아주 쉽게 생각하면, `ddof`가 1이면 $n-1$로 나누고 0이면 $n$으로 나누는 계산으로 생각해두면 된다. (라고 하셨지만... I want more) 특별한 경우를 제외하고 자유도는 1로 둔다. \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from scipy.stats import *\n",
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 분산 계산\n",
    "```\n",
    "numpy.var(x, ddof)\n",
    "numpy.array(x).var(ddof)\n",
    "Series(x).var(ddof)\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.5\n",
      "2.0\n",
      "2.0\n"
     ]
    }
   ],
   "source": [
    "x = [1, 2, 3, 4, 5]\n",
    "print(np.var(x, ddof = 1))        # 분모 = n-1 (가장 일반적임)\n",
    "print(np.array(x).var())          # 분모 = n (자유도를 설정하지 않음)\n",
    "print(pd.Series(x).var(ddof = 0)) # 분모 = n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 표준편차 계산\n",
    "\n",
    "```\n",
    "numpy.std(x, ddof)\n",
    "numpy.array(x, ddof).std()\n",
    "Series.std(x, ddof)\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.5811388300841898\n",
      "1.4142135623730951\n",
      "1.5811388300841898\n"
     ]
    }
   ],
   "source": [
    "x = [1, 2, 3, 4, 5]\n",
    "print(np.std(x, ddof = 1))        # 자유도 = 1\n",
    "print(np.array(x).std())          # 자유도 = 0\n",
    "print(pd.Series(x).std(ddof = 1)) # 자유도 = 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 변동계수\n",
    "\n",
    "```\n",
    "numpy.std(x, ddof) / numpy.mean(x)\n",
    "scipy.stats.variation(x)\n",
    "```\n",
    "\n",
    "### 변동계수의 필요성\n",
    "\n",
    "스케일차이가 존재하면 그에 따라 표준편차가 커질 수 있어서, 상대적인 편차를 보기위해 변동계수가 필요하며, 변동계수를 사용하기 위해서는 모든 데이터 값들이 양수여야 한다.  \n",
    "\n",
    "양수가 아닌데 보기 위해서는 따로 스케일링을 하고 보아야 한다고."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.5811388300841898\n",
      "15.811388300841896\n"
     ]
    }
   ],
   "source": [
    "# 표준편차 비교\n",
    "\n",
    "x1 = np.array([1, 2, 3, 4, 5])\n",
    "x2 = x1 * 10\n",
    "\n",
    "print(np.std(x1, ddof = 1))\n",
    "print(np.std(x2, ddof = 1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.47140452079103173\n",
      "0.4714045207910317\n"
     ]
    }
   ],
   "source": [
    "# 변동 계수 비교 (자유도 = 0)\n",
    "\n",
    "print(variation(x1)) \n",
    "print(variation(x2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.5270462766947299\n",
      "0.5270462766947299\n"
     ]
    }
   ],
   "source": [
    "# 변동 계수 함수 직접 계산 (자유도 = 1)\n",
    "\n",
    "print(np.std(x1, ddof = 1) / np.mean(x1))\n",
    "print(np.std(x2, ddof = 1) / np.mean(x2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 스케일링\n",
    "\n",
    "둘 이상의 변수의 값을 상대적으로 비교할 때 사용한다.  \n",
    "상대적으로 비교하기 위해 각 데이터에 있는 값을 상대적인 값을 갖도록 변환한다.  \n",
    "\n",
    "- Standard Scaling : x는 이론상 마이너스 무한대에서 무한대이다. 분포를 좀 더 고려해야 할 경우 사용한다.\n",
    "    $$ \\frac {x -\\mu} {\\sigma} $$\n",
    "- Min-max Scaling(Zero - one scaling) : 항상 0-1사이의 값을 가진다. 최대 최소의 값까지 스케일이 중요한 경우 사용한다. (경험상 머신러닝에서 더 많이 보았다!!!)\n",
    "    $$ \\frac {x- \\min(x)} {\\max{x} - \\min(x)}$$\n",
    "\n",
    "스케일링은 변수간 비교 뿐만 아니라, 머신러닝에서도 널리 사용된다.  \n",
    "sklean.preprocessing.은 머신러닝에서 더 쓰이기에 넘파이를 이용한 계산이 더 널리 쓰인다.  \n",
    "\n",
    "## 파이썬을 이용한 스케일링"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1, 2, 3, 4, 5])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([10, 20, 30, 40, 50])"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 스탠다드 스케일링\n",
    "\n",
    "```\n",
    "(x - x.mean()) / x.std()  # x : ndarray\n",
    "sklearn.preprocessing.StandardScaler\n",
    "```\n",
    "\n",
    "각 데이터가 0을 기준으로 어디에 위치하고 있는지를 한눈에 보기 쉽다. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-1.41421356 -0.70710678  0.          0.70710678  1.41421356]\n",
      "[-1.41421356 -0.70710678  0.          0.70710678  1.41421356]\n"
     ]
    }
   ],
   "source": [
    "z1 = (x1 - x1.mean()) / x1.std()\n",
    "z2 = (x2 - x2.mean()) / x2.std()\n",
    "\n",
    "print(z1)\n",
    "print(z2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 민맥스 스케일링\n",
    "```\n",
    "(x - x.mean()) / (x.max() - x.min())  # x : ndarray\n",
    "sklearn.preprocessing.MinMaxScaler\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.   0.25 0.5  0.75 1.  ]\n",
      "[0.   0.25 0.5  0.75 1.  ]\n"
     ]
    }
   ],
   "source": [
    "z1 = (x1 - x1.min()) / (x1.max() - x1.min())\n",
    "z2 = (x2 - x2.min()) / (x2.max() - x2.min())\n",
    "\n",
    "print(z1)\n",
    "print(z2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 사이킷런을 이용한 스케일링 \n",
    "데이터프레임을 가지고 실습해본다. \n",
    "\n",
    "머신러닝에 이용하는데, 각 특징별로 스케일링이 되도록 최적화되어있다.  \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>X1</th>\n",
       "      <th>X2</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1</td>\n",
       "      <td>10</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>2</td>\n",
       "      <td>20</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>3</td>\n",
       "      <td>30</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>4</td>\n",
       "      <td>40</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>5</td>\n",
       "      <td>50</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   X1  X2\n",
       "0   1  10\n",
       "1   2  20\n",
       "2   3  30\n",
       "3   4  40\n",
       "4   5  50"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# sklearn을 이용한 스케일링\n",
    "X = pd.DataFrame({\"X1\":[1, 2, 3, 4, 5], \n",
    "                  \"X2\": [10, 20, 30, 40, 50]})\n",
    "\n",
    "X"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>0</th>\n",
       "      <th>1</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0.00</td>\n",
       "      <td>0.00</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0.25</td>\n",
       "      <td>0.25</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>0.50</td>\n",
       "      <td>0.50</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>0.75</td>\n",
       "      <td>0.75</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>1.00</td>\n",
       "      <td>1.00</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "      0     1\n",
       "0  0.00  0.00\n",
       "1  0.25  0.25\n",
       "2  0.50  0.50\n",
       "3  0.75  0.75\n",
       "4  1.00  1.00"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from sklearn.preprocessing import MinMaxScaler\n",
    "scaler = MinMaxScaler()     # 인스턴스화\n",
    "Z = scaler.fit_transform(X) # fit_transform을 이용해 X를 변환 => 결과는 ndarray\n",
    "pd.DataFrame(Z)             # 보기 좋게 데이터프레임화"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
